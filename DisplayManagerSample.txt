using System;
using System.Collections;
using System.Threading;

namespace Max7219DisplayApp
{
    public class DisplayManager
    {
        private readonly Max7219.Max7219 _displayDriver;
        private readonly int _screenWidth;
        private const int _screenHeight = 8;
        private readonly byte[] _displayBuffer;
        private Hashtable _selectedFont;

        private bool _isColonVisible = true;
        private int _utcOffsetSeconds = 0;
        private string _temperature = "--°F";
        private string _scrollMessage = "Welcome to nanoFramework!";

        private bool _isScrolling = false;
        private Thread _scrollThread;

        public DisplayManager(Max7219.Max7219 driver, int deviceCount)
        {
            _displayDriver = driver;
            _screenWidth = deviceCount * 8;
            _displayBuffer = new byte[_screenWidth];
            _selectedFont = Font1.Characters; // Default to Font1
        }

        public void SetFont(Hashtable fontCharacters)
        {
            _selectedFont = fontCharacters;
        }

        public void Update()
        {
            if (!_isScrolling)
            {
                DrawStaticDisplay();
                Render();
            }
        }

        private void DrawStaticDisplay()
        {
            Clear();
            DateTime now = DateTime.UtcNow.AddSeconds(_utcOffsetSeconds);

            // Use a compatible format string
            string timeStr = now.ToString("HH:mm");

            // Draw Time (centered on left half)
            int leftHalfWidth = _screenWidth / 2;
            int timeWidth = GetTextWidth(timeStr);
            int timeX = (leftHalfWidth - timeWidth) / 2;
            DrawText(timeStr, timeX, 0);

            if (!_isColonVisible)
            {
                string hourStr = now.ToString("HH");
                int colonX = timeX + GetTextWidth(hourStr);
                int colonWidth = GetTextWidth(":");
                for (int i = 0; i < colonWidth; i++)
                {
                    DrawChar(' ', colonX + i, 0);
                }
            }

            // Draw Temperature (centered on right half)
            int rightHalfX = _screenWidth / 2;
            int tempWidth = GetTextWidth(_temperature);
            int tempX = rightHalfX + (leftHalfWidth - tempWidth) / 2;
            DrawText(_temperature, tempX, 0);
        }

        public void SetUtcOffset(int seconds)
        {
            _utcOffsetSeconds = seconds;
        }

        public void ToggleColon()
        {
            _isColonVisible = !_isColonVisible;
        }

        public void SetTemperature(string newTemperature)
        {
            _temperature = newTemperature;
        }

        public void SetScrollMessage(string newMessage)
        {
            _scrollMessage = newMessage;
        }

        public void StartMinuteScroll()
        {
            if (_isScrolling) return;

            _scrollThread = new Thread(() => ScrollTextOnRightHalf());
            _scrollThread.Start();
        }

        private void ScrollTextOnRightHalf()
        {
            _isScrolling = true;

            // Pre-render the time on the left
            byte[] leftHalfBuffer = new byte[_screenWidth / 2];
            DateTime now = DateTime.UtcNow.AddSeconds(_utcOffsetSeconds);
            // Use a compatible format string
            string timeStr = now.ToString("HH:mm");
            int timeWidth = GetTextWidth(timeStr);
            int timeX = ((_screenWidth / 2) - timeWidth) / 2;
            RenderTextToBuffer(timeStr, timeX, 0, leftHalfBuffer);

            // Pre-render the full scroll message to an off-screen buffer
            string fullScrollText = _scrollMessage + _temperature;
            int textWidth = GetTextWidth(fullScrollText);
            byte[] textBuffer = new byte[textWidth];
            RenderTextToBuffer(fullScrollText, 0, 0, textBuffer);

            int rightHalfStart = _screenWidth / 2;
            int rightHalfWidth = _screenWidth / 2;

            // Animate
            for (int x = -rightHalfWidth; x < textWidth; x++)
            {
                lock (_displayBuffer)
                {
                    Array.Clear(_displayBuffer, 0, _displayBuffer.Length);
                    Array.Copy(leftHalfBuffer, 0, _displayBuffer, 0, leftHalfBuffer.Length);

                    // Blink the colon during the scroll
                    if (!_isColonVisible)
                    {
                        string hourStr = now.ToString("HH");
                        int colonX = timeX + GetTextWidth(hourStr);
                        int colonWidth = GetTextWidth(":");
                        for (int i = 0; i < colonWidth; i++)
                        {
                            if (colonX + i < rightHalfStart)
                            {
                                _displayBuffer[colonX + i] = 0;
                            }
                        }
                    }

                    // Copy the visible portion of the text buffer to the right half
                    int start = x > 0 ? x : 0;
                    int end = (x + rightHalfWidth) < textWidth ? (x + rightHalfWidth) : textWidth;
                    int destStart = rightHalfStart + (-x > 0 ? -x : 0);

                    if (start < end)
                    {
                        Array.Copy(textBuffer, start, _displayBuffer, destStart, end - start);
                    }
                }
                Render();
                Thread.Sleep(25);
            }

            _isScrolling = false;
        }

        public void StartApMode(string apSsid)
        {
            if (_isScrolling) return;

            _scrollThread = new Thread(() => ApModeScrollLoop(apSsid));
            _scrollThread.Start();
        }

        private void ApModeScrollLoop(object ssidObj)
        {
            string apSsid = (string)ssidObj;
            _isScrolling = true;

            // Pre-render "Setup" on the left
            byte[] leftHalfBuffer = new byte[_screenWidth / 2];
            string setupText = "Setup";
            int setupWidth = GetTextWidth(setupText);
            int setupX = ((_screenWidth / 2) - setupWidth) / 2;
            RenderTextToBuffer(setupText, setupX, 0, leftHalfBuffer);

            // Pre-render the full scroll message to an off-screen buffer
            string fullScrollText = $"Connect to Access Point '{apSsid}' to setup networking... ";
            int textWidth = GetTextWidth(fullScrollText);
            byte[] textBuffer = new byte[textWidth];
            RenderTextToBuffer(fullScrollText, 0, 0, textBuffer);

            int rightHalfStart = _screenWidth / 2;
            int rightHalfWidth = _screenWidth / 2;

            while (true) // Loop the scroll indefinitely
            {
                // Animate
                for (int x = -rightHalfWidth; x < textWidth; x++)
                {
                    lock (_displayBuffer)
                    {
                        Array.Clear(_displayBuffer, 0, _displayBuffer.Length);
                        Array.Copy(leftHalfBuffer, 0, _displayBuffer, 0, leftHalfBuffer.Length);

                        // Copy the visible portion of the text buffer to the right half
                        int start = x > 0 ? x : 0;
                        int end = (x + rightHalfWidth) < textWidth ? (x + rightHalfWidth) : textWidth;
                        int destStart = rightHalfStart + (-x > 0 ? -x : 0);

                        if (start < end)
                        {
                            Array.Copy(textBuffer, start, _displayBuffer, destStart, end - start);
                        }
                    }
                    Render();
                    Thread.Sleep(35); // Slow down the AP scroll slightly
                }
            }
        }


        public void RunStartupSequence(string ipAddress)
        {
            ShowTwoWords("Hello", "World");
            Thread.Sleep(2000);
            ShowTwoWords("Config", "IP");
            Thread.Sleep(2000);
            ScrollFullWidth(ipAddress);
        }

        private void ScrollFullWidth(string text)
        {
            if (_isScrolling) return;
            _isScrolling = true;

            int textWidth = GetTextWidth(text);
            byte[] textBuffer = new byte[textWidth];
            RenderTextToBuffer(text, 0, 0, textBuffer);

            for (int x = -_screenWidth; x < textWidth; x++)
            {
                lock (_displayBuffer)
                {
                    Array.Clear(_displayBuffer, 0, _displayBuffer.Length);
                    int start = x > 0 ? x : 0;
                    int end = (x + _screenWidth) < textWidth ? (x + _screenWidth) : textWidth;
                    int destStart = -x > 0 ? -x : 0;

                    if (start < end)
                    {
                        Array.Copy(textBuffer, start, _displayBuffer, destStart, end - start);
                    }
                }
                Render();
                Thread.Sleep(25);
            }
            _isScrolling = false;
        }


        private void RenderTextToBuffer(string text, int x, int y, byte[] buffer)
        {
            int currentX = x;
            foreach (char c in text)
            {
                if (_selectedFont.Contains(c))
                {
                    byte[] charData = (byte[])_selectedFont[c];
                    for (int i = 0; i < charData.Length; i++)
                    {
                        if (currentX + i >= 0 && currentX + i < buffer.Length)
                        {
                            buffer[currentX + i] = charData[i];
                        }
                    }
                    currentX += charData.Length;
                }
            }
        }


        public void ShowTwoWords(string leftWord, string rightWord)
        {
            Clear();
            int leftHalfWidth = _screenWidth / 2;
            int leftWordWidth = GetTextWidth(leftWord);
            int leftX = (leftHalfWidth - leftWordWidth) / 2;
            DrawText(leftWord, leftX, 0);

            int rightHalfX = _screenWidth / 2;
            int rightWordWidth = GetTextWidth(rightWord);
            int rightX = rightHalfX + (leftHalfWidth - rightWordWidth) / 2;
            DrawText(rightWord, rightX, 0);
            Render();
        }

        public void UpdateProgressBar(int level) // level 0-8
        {
            byte mask = 0;
            if (level > 0)
            {
                mask = (byte)(0xFF << (8 - level));
            }
            _displayBuffer[0] = mask;
            Render();
        }

        public void ClearProgressBar()
        {
            _displayBuffer[0] = 0;
            Render();
        }

        public int GetTextWidth(string text)
        {
            int width = 0;
            foreach (char c in text)
            {
                if (_selectedFont.Contains(c))
                {
                    width += ((byte[])_selectedFont[c]).Length;
                }
            }
            return width;
        }

        private void DrawText(string text, int x, int y)
        {
            int currentX = x;
            foreach (char c in text)
            {
                currentX += DrawChar(c, currentX, y);
            }
        }

        private int DrawChar(char c, int x, int y)
        {
            if (_selectedFont.Contains(c))
            {
                byte[] charData = (byte[])_selectedFont[c];
                for (int i = 0; i < charData.Length; i++)
                {
                    if (x + i >= 0 && x + i < _screenWidth)
                    {
                        _displayBuffer[x + i] = charData[i];
                    }
                }
                return charData.Length;
            }
            return 0;
        }

        public void SetPixel(int x, int y, bool on)
        {
            if (x < 0 || x >= _screenWidth || y < 0 || y >= _screenHeight) return;
            if (on)
            {
                _displayBuffer[x] |= (byte)(1 << y);
            }
            else
            {
                _displayBuffer[x] &= (byte)~(1 << y);
            }
        }

        public void Clear()
        {
            Array.Clear(_displayBuffer, 0, _displayBuffer.Length);
        }

        public void Render()
        {
            lock (_displayBuffer)
            {
                _displayDriver.Render(_displayBuffer);
            }
        }
    }
}

